{
  config,
  lib,
  pkgs,
  ...
}:

with lib;

let
  cfg = config.audio;

  mkAppRoutingRules =
    categories:
    let
      categoryRules = mapAttrsToList (
        categoryName: categoryConfig:
        let
          targetName = categoryName;

          nameRules = map (appName: {
            matches = [ { "application.name" = "~${appName}"; } ];
            actions.update-props."node.target" = targetName;
          }) categoryConfig.appNames;

          binaryRules = map (binary: {
            matches = [ { "application.process.binary" = binary; } ];
            actions.update-props."node.target" = targetName;
          }) categoryConfig.binaries;

        in
        nameRules ++ binaryRules
      ) categories;

    in
    flatten categoryRules;

in
{
  options.audio = {
    enable = mkEnableOption "the custom PipeWire audio configuration";

    input = mkOption {
      type = types.str;
      description = "The name of the hardware source (microphone) device.";
      example = "alsa_input.pci-0000_01_00.1.analog-stereo";
    };

    output = mkOption {
      type = types.str;
      description = "The name of the hardware sink (output) device.";
      example = "alsa_output.pci-0000_00_1f.3.analog-stereo";
    };

    appCategories = mkOption {
      type = types.attrsOf (
        types.submodule {
          options = {
            limitThreshold = mkOption {
              type = types.float;
              default = -14.0;
              description = "Limiter threshold in dB for this category.";
            };

            appNames = mkOption {
              type = types.listOf types.str;
              default = [ ];
              description = "List of application names (regex patterns) to match";
              example = [
                "LibreWolf"
                "Firefox"
                "Chromium.*"
              ];
            };

            binaries = mkOption {
              type = types.listOf types.str;
              default = [ ];
              description = "List of binary names to match";
              example = [
                "spotify"
                "vlc"
              ];
            };
          };
        }
      );
      description = "Application categories for audio routing and processing";
    };

    fallbackCategory = mkOption {
      type = types.enum (attrNames cfg.appCategories);
      description = "Default category for applications that don't match any specific rules.";
    };

    micProcess = mkOption {
      type = types.submodule {
        options = {
          enable = mkEnableOption "RNNoise-based microphone noise suppression";

          vadThreshold = mkOption {
            type = types.float;
            default = 50.0;
            description = "Voice Activity Detection (VAD) threshold percentage for RNNoise.";
            example = 75.0;
          };

          compressor = mkOption {
            type = types.submodule {
              options = {
                attack = mkOption {
                  type = types.float;
                  description = "Attack time (ms)";
                  example = 10.6;
                };
                release = mkOption {
                  type = types.float;
                  description = "Release time (ms)";
                  example = 500;
                };
                threshold = mkOption {
                  type = types.float;
                  description = "Threshold level (dB)";
                  example = -18.3;
                };
                ratio = mkOption {
                  type = types.float;
                  description = "Ratio (1:n)";
                  example = 4.0;
                };
                makeup = mkOption {
                  type = types.float;
                  description = "Makeup gain (dB)";
                  example = 5.9;
                };
              };
            };
            description = "Compressor options";
          };
        };
      };
      description = "Microphone processing options";
    };

    eq = mkOption {
      type = types.submodule {
        options = {
          enable = mkEnableOption "a parametric equalizer on the main output";

          file = mkOption {
            type = types.str;
            example = "/path/to/parametric-eq.txt";
            description = "Absolute path to parametric EQ settings file generated by AutoEQ";
          };
        };
      };
      default = { };
      example = {
        enable = true;
        file = "/path/to/parametric-eq.txt";
      };
      description = "Equalizer options";
    };

  };

  config = mkIf cfg.enable {

    environment.systemPackages =
      with pkgs;
      [
        helvum
        qpwgraph
        ladspaPlugins

      ]
      ++ (optional cfg.micProcess.enable rnnoise-plugin);

    security.rtkit.enable = true;

    services.pipewire = {
      enable = true;
      alsa.enable = true;
      pulse.enable = true;
      jack.enable = true;
      wireplumber.enable = true;
    };

    services.pipewire.wireplumber.extraConfig."99-alsa-rules" = {
      "monitor.alsa.rules" = [
        {
          matches = [ { "node.name" = cfg.output; } ];
          actions.update-props = {
            "api.alsa.period-num" = 32;
            "api.alsa.headroom" = 8192;
            "api.alsa.disable-tsched" = true;
          };
        }
        {
          matches = [ { "node.name" = cfg.input; } ];
          actions.update-props = {
            "api.alsa.period-num" = 32;
            "api.alsa.headroom" = 8192;
            "api.alsa.disable-tsched" = true;
          };
        }
      ];
    };

    services.pipewire.extraConfig.pipewire-pulse."99-app-routing" = {
      "pulse.rules" = [
        {
          matches = [ { "application.name" = "~.*"; } ];
          actions.update-props."node.target" = cfg.fallbackCategory;
        }
      ]
      ++ (mkAppRoutingRules cfg.appCategories);
    };

    services.pipewire.extraConfig.pipewire."10-processing-and-linking" =
      let
        mkAppChain = categoryName: categoryConfig: {
          name = "libpipewire-module-filter-chain";
          args = {
            "capture.props" = {
              "node.name" = "${categoryName}";
              "node.description" = "${categoryName} (Raw)";
              "media.class" = "Audio/Sink";
              "audio.position" = "FL,FR";
            };
            "playback.props" = {
              "node.name" = "${categoryName}Processed";
              "node.description" = "${categoryName} (Processed)";
              "media.class" = "Audio/Source";
            };
            "filter.graph" = {
              nodes = [
                {
                  type = "ladspa";
                  plugin = "${pkgs.ladspaPlugins}/lib/ladspa/fast_lookahead_limiter_1913.so";
                  label = "fastLookaheadLimiter";
                  control = {
                    "Limit (dB)" = categoryConfig.limitThreshold;
                    "Release time (s)" = 0.1;
                  };
                }
              ];
            };
          };
        };

        mkMainLoopback = name: {
          name = "libpipewire-module-loopback";
          args = {
            "node.description" = "${name} ➜ Main";
            "capture.props"."node.target" = "${name}Processed";
            "playback.props"."node.target" = if cfg.eq.enable then "MainEQ" else cfg.output;
          };
        };

        appChains = mapAttrsToList mkAppChain cfg.appCategories;
        mainLoopbacks = map (name: mkMainLoopback name) (attrNames cfg.appCategories);

      in
      {
        "context.modules" =
          appChains
          ++ mainLoopbacks
          ++ [

            # --- Microphone Processing ---
            (
              if cfg.micProcess.enable then
                {
                  name = "libpipewire-module-filter-chain";
                  args = {
                    "capture.props" = {
                      "node.name" = "MicRaw";
                      "media.class" = "Audio/Sink";
                    };
                    "playback.props" = {
                      "node.name" = "MicFiltered";
                      "media.class" = "Audio/Source";
                    };
                    "filter.graph" = {
                      nodes = [
                        {
                          type = "ladspa";
                          name = "rnnoise";
                          plugin = "${pkgs.rnnoise-plugin}/lib/ladspa/librnnoise_ladspa.so";
                          label = "noise_suppressor_stereo";
                          control."VAD Threshold (%)" = cfg.micProcess.vadThreshold;
                        }
                        {
                          type = "ladspa";
                          plugin = "${pkgs.ladspaPlugins}/lib/ladspa/sc4_1882.so";
                          name = "compressor";
                          label = "sc4";
                          control = {
                            "Attack time (ms)" = 10.6;
                            "Release time (ms)" = 500;
                            "Threshold level (dB)" = -18.3;
                            "Ratio (1:n)" = 4.0;
                            "Makeup gain (dB)" = 5.9;
                          };
                        }
                      ];

                      links = [
                        {
                          output = "rnnoise:Output (L)";
                          input = "compressor:Left input";
                        }
                        {
                          output = "rnnoise:Output (R)";
                          input = "compressor:Right input";
                        }
                      ];
                    };
                  };
                }
              else
                {
                  # If mic processing is off, create a simple pass-through virtual device
                  name = "libpipewire-module-adapter";
                  args = {
                    "factory.name" = "support.null-audio-sink";
                    "node.name" = "MicRaw";
                    "media.class" = "Audio/Sink";
                  };
                }
            )
            {
              name = "libpipewire-module-loopback";
              args = {
                "node.description" = "HW-Mic ➜ Mic Processing";
                "capture.props"."node.target" = cfg.input;
                "playback.props"."node.target" = if cfg.micProcess.enable then "MicRaw" else "MicFiltered";
              };
            }
            (mkIf (!cfg.micProcess.enable) {
              name = "libpipewire-module-adapter";
              args = {
                "factory.name" = "support.null-audio-sink";
                "node.name" = "MicFiltered";
                "media.class" = "Audio/Source";
              };
            })

            # --- Headphone EQ and Final Output  ---
            (
              if cfg.eq.enable then
                {
                  name = "libpipewire-module-filter-chain";
                  args = {
                    "capture.props" = {
                      "node.name" = "MainEQ";
                      "node.description" = "Main Mix (Post-EQ)";
                      "media.class" = "Audio/Sink";
                      "audio.position" = "FL,FR";
                    };
                    "playback.props" = {
                      "node.target" = cfg.output;
                    };
                    "filter.graph" = {
                      nodes = [
                        {
                          type = "builtin";
                          label = "param_eq";

                          config.filename = cfg.eq.file;
                        }
                      ];
                    };
                  };
                }
              else
                {
                  # If EQ is disabled, create a simple sink that acts as the main mix and outputs directly to hardware.
                  name = "libpipewire-module-loopback";
                  args = {
                    "capture.props" = {
                      "node.name" = "MainEQ";
                      "node.description" = "Main Mix (Passthrough)";
                      "media.class" = "Audio/Sink";
                      "audio.position" = "FL,FR";
                    };
                    "playback.props" = {
                      "node.target" = cfg.output;
                    };
                  };
                }
            )

            # --- Stream Mix and Virtual Mic ---
            {
              factory = "adapter";
              args = {
                "factory.name" = "support.null-audio-sink";
                "node.name" = "Mix_Stream";
                "node.description" = "Stream Mix";
                "media.class" = "Audio/Sink";
                "audio.position" = "FL,FR";
              };
            }
            {
              name = "libpipewire-module-loopback";
              args = {
                "node.description" = "Mic ➜ Stream mix";
                "capture.props"."node.target" = "MicFiltered";
                "playback.props"."node.target" = "Mix_Stream";
              };
            }
            {
              name = "libpipewire-module-loopback";
              args = {
                "node.description" = "Stream mix ➜ VirtualMic";
                "capture.props" = {
                  "node.target" = "Mix_Stream";
                  "stream.monitor" = true;
                };
                "playbook.props" = {
                  "media.class" = "Audio/Source";
                  "node.name" = "VirtualMic";
                  "node.description" = "Input: Stream mix";
                };
              };
            }
          ];
      };
  };
}
