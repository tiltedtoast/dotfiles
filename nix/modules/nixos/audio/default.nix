{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.audio;

  mkAppRoutingRules =
    categories:
    let
      categoryRules = lib.mapAttrsToList (
        categoryName: categoryConfig:
        let
          targetName = categoryName;

          nameRules = map (appName: {
            matches = [ { "application.name" = "~${appName}"; } ];
            actions.update-props."node.target" = targetName;
          }) categoryConfig.appNames;

          binaryRules = map (binary: {
            matches = [ { "application.process.binary" = binary; } ];
            actions.update-props."node.target" = targetName;
          }) categoryConfig.binaries;

        in
        nameRules ++ binaryRules
      ) categories;

    in
    lib.flatten categoryRules;

in
{
  options.audio = {
    enable = lib.mkEnableOption "the custom PipeWire audio configuration";

    input = lib.mkOption {
      type = lib.types.str;
      description = "The name of the hardware source (microphone) device.";
      example = "alsa_input.pci-0000_01_00.1.analog-stereo";
    };

    output = lib.mkOption {
      type = lib.types.str;
      description = "The name of the hardware sink (output) device.";
      example = "alsa_output.pci-0000_00_1f.3.analog-stereo";
    };

    appCategories = lib.mkOption {
      type = lib.types.attrsOf (
        lib.types.submodule {
          options = {
            limitThreshold = lib.mkOption {
              type = lib.types.float;
              default = -14.0;
              description = "Limiter threshold in dB for this category.";
            };

            appNames = lib.mkOption {
              type = lib.types.listOf lib.types.str;
              default = [ ];
              description = "List of application names (regex patterns) to match";
              example = [
                "LibreWolf"
                "Firefox"
                "Chromium.*"
              ];
            };

            binaries = lib.mkOption {
              type = lib.types.listOf lib.types.str;
              default = [ ];
              description = "List of binary names to match";
              example = [
                "spotify"
                "vlc"
              ];
            };
          };
        }
      );
      description = "Application categories for audio routing and processing";
    };

    fallbackCategory = lib.mkOption {
      type = lib.types.enum (lib.attrNames cfg.appCategories);
      description = "Default category for applications that don't match any specific rules.";
    };

    micProcess = lib.mkOption {
      type = lib.types.submodule {
        options = {
          enable = lib.mkEnableOption "RNNoise-based microphone noise suppression";

          vadThreshold = lib.mkOption {
            type = lib.types.float;
            default = 50.0;
            description = "Voice Activity Detection (VAD) threshold percentage for RNNoise.";
            example = 75.0;
          };

          compressor = lib.mkOption {
            type = lib.types.submodule {
              options = {
                attackTime = lib.mkOption {
                  type = lib.types.float;
                  description = "Attack time (ms)";
                  example = 10.6;
                };
                releaseTime = lib.mkOption {
                  type = lib.types.int;
                  description = "Release time (ms)";
                  example = 500;
                };
                threshold = lib.mkOption {
                  type = lib.types.float;
                  description = "Threshold level (dB)";
                  example = -18.3;
                };
                ratio = lib.mkOption {
                  type = lib.types.float;
                  description = "Ratio (1:n)";
                  example = 4.0;
                };
                makeupGain = lib.mkOption {
                  type = lib.types.float;
                  description = "Makeup gain (dB)";
                  example = 5.9;
                };
              };
            };
            description = "Compressor options";
          };
        };
      };
      description = "Microphone processing options";
    };

    eq = lib.mkOption {
      type = lib.types.submodule {
        options = {
          enable = lib.mkEnableOption "a parametric equalizer on the main output";

          file = lib.mkOption {
            type = lib.types.str;
            example = "/path/to/parametric-eq.txt";
            description = "Absolute path to parametric EQ settings file generated by AutoEQ";
          };
        };
      };
      default = { };
      example = {
        enable = true;
        file = "/path/to/parametric-eq.txt";
      };
      description = "Equalizer options";
    };

  };

  config = lib.mkIf cfg.enable {

    environment.systemPackages =
      with pkgs;
      [
        helvum
        qpwgraph
        ladspaPlugins

      ]
      ++ (lib.optional cfg.micProcess.enable rnnoise-plugin);

    security.rtkit.enable = true;

    services.pipewire = {
      enable = true;
      alsa.enable = true;
      pulse.enable = true;
      jack.enable = true;
      wireplumber.enable = true;
    };

    services.pipewire.wireplumber.extraConfig."99-alsa-rules" = {
      "monitor.alsa.rules" = [
        {
          matches = [ { "node.name" = cfg.output; } ];
          actions.update-props = {
            "api.alsa.period-num" = 32;
            "api.alsa.headroom" = 8192;
            "api.alsa.disable-tsched" = true;
          };
        }
        {
          matches = [ { "node.name" = cfg.input; } ];
          actions.update-props = {
            "api.alsa.period-num" = 32;
            "api.alsa.headroom" = 8192;
            "api.alsa.disable-tsched" = true;
          };
        }
      ];
    };

    services.pipewire.extraConfig.pipewire-pulse."99-app-routing" = {
      "pulse.rules" = [
        {
          matches = [ { "application.name" = "~.*"; } ];
          actions.update-props."node.target" = cfg.fallbackCategory;
        }
      ]
      ++ (mkAppRoutingRules cfg.appCategories);
    };

    services.pipewire.extraConfig.pipewire."10-processing-and-linking" =
      let
        mkAppChain = categoryName: categoryConfig: {
          name = "libpipewire-module-filter-chain";
          args = {
            "capture.props" = {
              "node.name" = "${categoryName}";
              "node.description" = "${categoryName} (Raw)";
              "media.class" = "Audio/Sink";
              "audio.position" = "FL,FR";
            };
            "playback.props" = {
              "node.name" = "${categoryName}Processed";
              "node.description" = "${categoryName} (Processed)";
              "media.class" = "Audio/Source";
            };
            "filter.graph" = {
              nodes = [
                {
                  type = "ladspa";
                  plugin = "${pkgs.ladspaPlugins}/lib/ladspa/fast_lookahead_limiter_1913.so";
                  label = "fastLookaheadLimiter";
                  control = {
                    "Limit (dB)" = categoryConfig.limitThreshold;
                    "Release time (s)" = 0.1;
                  };
                }
              ];
            };
          };
        };

        mkMainLoopback = name: {
          name = "libpipewire-module-loopback";
          args = {
            "node.description" = "${name} ➜ Main";
            "capture.props"."node.target" = "${name}Processed";
            "playback.props"."node.target" = if cfg.eq.enable then "MainEQ" else cfg.output;
          };
        };

        appChains = lib.mapAttrsToList mkAppChain cfg.appCategories;
        mainLoopbacks = map (name: mkMainLoopback name) (lib.attrNames cfg.appCategories);

        micProcessingSetup =
          if cfg.micProcess.enable then
            [
              {
                name = "libpipewire-module-filter-chain";
                args = {
                  "capture.props" = {
                    "node.name" = "MicRaw";
                    "node.description" = "HW Mic (Raw Input)";
                    "media.class" = "Audio/Sink";
                  };
                  "playback.props" = {
                    "node.name" = "MicProcessed";
                    "node.description" = "HW Mic (Processed)";
                    "media.class" = "Audio/Source";
                  };
                  "filter.graph" = {
                    nodes = [
                      {
                        type = "ladspa";
                        name = "rnnoise";
                        plugin = "${pkgs.rnnoise-plugin}/lib/ladspa/librnnoise_ladspa.so";
                        label = "noise_suppressor_stereo";
                        control."VAD Threshold (%)" = cfg.micProcess.vadThreshold;
                      }
                      {
                        type = "ladspa";
                        plugin = "${pkgs.ladspaPlugins}/lib/ladspa/sc4_1882.so";
                        name = "compressor";
                        label = "sc4";
                        control = with cfg.micProcess.compressor; {
                          "Attack time (ms)" = attackTime;
                          "Release time (ms)" = releaseTime;
                          "Threshold level (dB)" = threshold;
                          "Ratio (1:n)" = ratio;
                          "Makeup gain (dB)" = makeupGain;
                        };
                      }
                    ];
                    links = [
                      {
                        output = "rnnoise:Output (L)";
                        input = "compressor:Left input";
                      }
                      {
                        output = "rnnoise:Output (R)";
                        input = "compressor:Right input";
                      }
                    ];
                  };
                };
              }
              {
                name = "libpipewire-module-loopback";
                args = {
                  "node.description" = "HW-Mic ➜ Processing Chain";
                  "capture.props"."node.target" = cfg.input;
                  "playback.props"."node.target" = "MicRaw";
                };
              }
            ]
          else
            [
              {
                name = "libpipewire-module-loopback";
                args = {
                  "node.description" = "HW-Mic ➜ Passthrough";
                  "capture.props"."node.target" = cfg.input;
                  "playback.props" = {
                    "node.name" = "MicProcessed";
                    "node.description" = "Hardware Mic (Passthrough)";
                    "media.class" = "Audio/Source";
                  };
                };
              }
            ];

      in
      {
        "context.modules" =
          appChains
          ++ mainLoopbacks
          ++ micProcessingSetup
          ++ [
            {
              name = "libpipewire-module-loopback";
              args = {
                "node.description" = "Virtual Mic (Source & Mixer)";
                "capture.props" = {
                  "node.name" = "VirtualMicInput";
                  "node.description" = "Virtual Mic Input (Mixer)";
                  "media.class" = "Audio/Sink";
                };
                "playback.props" = {
                  "node.name" = "VirtualMic";
                  "node.description" = "Input: Virtual Microphone";
                  "media.class" = "Audio/Source";
                };
              };
            }
            {
              name = "libpipewire-module-loopback";
              args = {
                "node.description" = "Processed Mic ➜ Virtual Mic Mixer";
                "capture.props"."node.target" = "MicProcessed";
                "playback.props"."node.target" = "VirtualMicInput";
              };
            }
            (
              if cfg.eq.enable then
                {
                  name = "libpipewire-module-filter-chain";
                  args = {
                    "capture.props" = {
                      "node.name" = "MainEQ";
                      "node.description" = "Main Mix (Pre-EQ)";
                      "media.class" = "Audio/Sink";
                      "audio.position" = "FL,FR";
                    };
                    "playback.props" = {
                      "node.target" = cfg.output;
                    };
                    "filter.graph" = {
                      nodes = [
                        {
                          type = "builtin";
                          label = "param_eq";
                          config.filename = cfg.eq.file;
                        }
                      ];
                    };
                  };
                }
              else
                {
                  name = "libpipewire-module-loopback";
                  args = {
                    "capture.props" = {
                      "node.name" = "MainEQ";
                      "node.description" = "Main Mix (Passthrough)";
                      "media.class" = "Audio/Sink";
                      "audio.position" = "FL,FR";
                    };
                    "playback.props" = {
                      "node.target" = cfg.output;
                    };
                  };
                }
            )
          ];
      };
  };
}
